{"./":{"url":"./","title":"Introduction","keywords":"","body":"个人学习笔记及总结： 一、Python 二、Golang 三、JavaScript 四、NodeJS 五、DevOps 六、DataBase 七、Commands 八、OSS Copyright && Guiyin.Xiong From ==>> notebook.sslinux.com all right reserved，powered by Gitbook2017年6月12日 2017-09-20 16:37:48 "},"Python/Python.html":{"url":"Python/Python.html","title":"一、Python","keywords":"","body":"一、Python 00、在CentOS7上搭建多版本的Python开发环境 01、Python快速入门 02、Python内置类型 00、在CentOS7上搭建多版本的Python开发环境 01、Python快速入门 02、Python内置类型 Copyright && Guiyin.Xiong From ==>> notebook.sslinux.com all right reserved，powered by Gitbook2017年6月12日 2017-09-20 16:37:48 "},"Python/00Environment.html":{"url":"Python/00Environment.html","title":"00.Environment","keywords":"","body":"目录 Centos7打造多版本Python开发环境 1.安装IDEA 2.安装git 3.安装pyenv 卸载pyenv 通过PyPi的方式安装pyenv 4.安装特定版本的Python 安装编译工具 安装依赖包 安装python3.5.2 使用pyenv python IDE pip命令 pip安装jupyter 启动jupyter Centos7打造多版本Python开发环境 安装Centos 7，配置网络，配置yum，安装desktop； 关闭firewalld和selinux； 返回目录 1.安装IDEA 下载地址：https://download.jetbrains.8686c.com/idea/ideaIU-2016-2.4.tar.gz tar xf ideaIU-2016.2.4.tar.gz ln -sv idea-IU-162.2032.8 idea cd idea ./bin/idea.sh # 因为我下的版本是包含了JDK的，所以不需要单独安装JDK，否则需要安装并配置JDK； ln -sv ./bin/idea.sh /usr/bin/idea # 为了方便，创建一个软链接； 上述命令启动了安装界面，顺着界面就可以完成安装了，可以为所有用户创建一个快捷图标； 然后在初始界面点击configure --> 并安装plugins --> python --> Install 安装完成后就可以创建python项目了. 返回目录 2.安装git [sslinux@localhost ~]$ sudo yum -y install git 返回目录 3.安装pyenv 为了安装pyenv方便，作者开发了另一个项目：pyenv-installer来帮助广大劳苦大众安装pyenv； pyenv：https://github.com/yyuu/pyenv/ pyenv-installer：https://github.com/yyuu/pyenv-installer 使用pyenv-installer安装pyenv： $ curl -L https://raw.githubusercontent.com/yyuu/pyenv-installer/master/bin/pyenv-installer | bash 修改环境变量： [sslinux@localhost ~]$ vim ~/.bash_profile # 仅对当前用户有效； export PATH=\"/home/sslinux/.pyenv/bin:$PATH\" eval \"$(pyenv init -)\" eval \"$(pyenv virtualenv-init -)\" 所有用户有效： [sslinux@localhost ~]$ cat /etc/profile.d/pyenv.sh export PATH=\"/home/sslinux/.pyenv/bin:$PATH\" eval \"$(pyenv init -)\" eval \"$(pyenv virtualenv-init -)\" 更新pyenv： pyenv update 返回目录 卸载pyenv pyenv 默认安装在环境变量$PYENV_ROOT所指定的目录下(默认为:~/.pyenv) $ rm -rf ~/.pyenv # 将配置文件中的相关配置删除掉； export PATH=\"/home/sslinux/.pyenv/bin:$PATH\" eval \"$(pyenv init -)\" eval \"$(pyenv virtualenv-init -)\" 返回目录 通过PyPi的方式安装pyenv $ pip install --egg pyenv 返回目录 4.安装特定版本的Python 安装编译工具 [sslinux@localhost ~]$ sudo yum -y install gcc make patch 安装依赖包 # Fedora/RHEL/CentOS [sslinux@localhost ~]$ sudo yum -y install gdbm-devel openssl-devel \\ sqlite-devel readline-devel zlib-devel bzip2-devel # Ubuntu/Kali/Debian sudo apt-get update sudo apt-get install make build-essential libssl-dev zlib1g-dev sudo apt-get install libbz2-dev libreadline-dev libsqlite3-dev wget curl sudo apt-get install llvm libncurses5-dev libncursesw5-dev 返回目录 安装python3.5.2 [sslinux@localhost ~]$ pyenv install 3.5.2 返回目录 使用pyenv [sslinux@localhost .pyenv]$ pyenv pyenv 1.0.2 Usage: pyenv [] Some useful pyenv commands are: commands List all available pyenv commands # 列出所有可用的子命令，包括virtualenv local Set or show the local application-specific Python version global Set or show the global Python version shell Set or show the shell-specific Python version install Install a Python version using python-build uninstall Uninstall a specific Python version rehash Rehash pyenv shims (run this after installing executables) version Show the current Python version and its origin versions List all Python versions available to pyenv which Display the full path to an executable whence List all Python versions that contain the given executable See `pyenv help ` for information on a specific command. For full documentation, see: https://github.com/yyuu/pyenv#readme local命令 local命令切换当前目录及子目录的Python版本，可以通过删除'.python-version'恢复默认Python版本； global命令 global切换全局默认Python版本，不建议这么使用； install命令 安装指定版本，后面直接跟版本号即可； uninstall命令 卸载某个版本，包括虚拟环境； 环境配置原理 python的环境是基于site的，即整个机器的python环境是一样的； java是基于project的，每个项目可以使用不同的java环境； 返回目录 virtualenv命令 创建虚拟环境： pyenv virtualenv $python_version $name [sslinux@localhost .pyenv]$ pyenv help virtualenv Usage: pyenv virtualenv [-f|--force] [VIRTUALENV_OPTIONS] [version] pyenv virtualenv --version pyenv virtualenv --help -f/--force Install even if the version appears to be installed already [sslinux@localhost ~]$ pyenv virtualenv 3.5.2 py2go # 创建一个虚拟环境，名叫py2go Ignoring indexes: https://pypi.python.org/simple Requirement already satisfied (use --upgrade to upgrade): setuptools in /home/sslinux/.pyenv/versions/3.5.2/envs/py2go/lib/python3.5/site-packages Requirement already satisfied (use --upgrade to upgrade): pip in /home/sslinux/.pyenv/versions/3.5.2/envs/py2go/lib/python3.5/site-packages [sslinux@localhost ~]$ pyenv versions * system (set by /home/sslinux/.pyenv/version) 3.5.2 3.5.2/envs/py2go 3.5.2/envs/symbio py2go symbio 切换到虚拟环境： [sslinux@localhost ~]$ pyenv local py2go # 切换本地python环境为指定虚拟环境 (py2go) [sslinux@localhost ~]$ python -V Python 3.5.2 (py2go) [sslinux@localhost ~]$ pyenv version py2go (set by /home/sslinux/.python-version) 所有使用pyenv创建的python版本，都在~/.pyenv/versions/目录下； python IDE Pycharm IDEA Atom vscode 返回目录 pip命令 [sslinux@localhost ~]$ pyenv versions * system (set by /home/sslinux/.python-version) 3.5.2 3.5.2/envs/py2go py2go [sslinux@localhost ~]$ pyenv local py2go (py2go) [sslinux@localhost ~]$ mkdir ~/.pip (py2go) [sslinux@localhost ~]$ vim ~/.pip/pip.conf (py2go) [sslinux@localhost ~]$ cat ~/.pip/pip.conf # 为提高下载速度设置； [global] index-url = http://mirrors.aliyun.com/pypi/simple/ trusted-host = mirrors.aliyun.com 在虚拟环境中，使用pip安装ipython，安装其他模块和包也是一样的； (py2go) [sslinux@localhost ~]$ pip install ipython 返回目录 pip安装jupyter 安装文档：http://jupyter.org/install.html pip3 install --upgrade pip pip3 install jupyter (py2go) [sslinux@localhost ~]$ jupyter -h usage: jupyter [-h] [--version] [--config-dir] [--data-dir] [--runtime-dir] [--paths] [--json] [subcommand] Jupyter: Interactive Computing positional arguments: subcommand the subcommand to launch optional arguments: -h, --help show this help message and exit --version show the jupyter command's version and exit --config-dir show Jupyter config dir --data-dir show Jupyter data dir --runtime-dir show Jupyter runtime dir --paths show all Jupyter paths. Add --json for machine-readable format. --json output paths as machine-readable json Available subcommands: console kernelspec migrate nbconvert nbextension notebook qtconsole serverextension troubleshoot trust 返回目录 启动jupyter (py2go) [sslinux@localhost ~]$ jupyter notebook --no-browser --ip=0.0.0.0 此时便可以在本地的浏览器中使用ip加端口进行访问了； 返回目录 Copyright && Guiyin.Xiong From ==>> notebook.sslinux.com all right reserved，powered by Gitbook2017年6月12日 2017-09-20 16:37:48 "},"Python/01QuickStart.html":{"url":"Python/01QuickStart.html","title":"01.QuickStart","keywords":"","body":"目录 python资源 编程语言 按高级低级分类： 按编程范式分类： python语言 应用场景 Python的缺点 python语言执行流程 python解释器 python性能优化工具 编写执行Python代码 python程序可以分解成模块、语句、表达式和对象 python基础语法 在Linux上使用新版本的python 1、编译安装新版本至某特定路径； 2、使用pyenv管理多版本并存，详见python编程环境准备； 数据结构 python的关键要素 内置函数 基本数据类型 对象引用 组合数据类型 逻辑操作符 控制流语句 算术操作符 输入输出 print格式化输出 数据类型转换 函数的创建与调用 python有众多内置函数 编程习惯 变量的命名规则 命名惯例 Python编程风格 标识符 Python标识符 注释 Python命名惯例 Python文件主程序 python资源 Python官网 Python解释器下载 Python官方文档 Python第三方库 Github Python资源整合 返回目录 编程语言 按高级低级分类： 用户：问题，问题空间； 计算机：解决问题，解空间； 把用户在问题空间中的问题抽象为解空间中能解决问题的方案就是编程； 编程语言迭代：机器代码 --> 微码编程 --> 高级语言 把人类能表述的解决方案翻译为计算机能识别的解决方案的翻译官是：编译器或解释器； 高级和低级：指的是，是否离人类语言或思维方式接近；越高级的语言，离人类越近，人类编程容易，机器理解困难，执行效率低； 按编程范式分类： 面向过程： 以指令为中心，由指令处理数据； 考虑如何组织代码解决问题； 面向对象： 以数据为中心，所有的处理代码都围绕数据展开； 如何设计数据结构组织数据，并提供对此类数据所允许的处理操作； python既可以面向过程，也可以面向对象，但python中的数据都存储为对象； 返回目录 python语言 应用场景 shell编程，不建议使用；此种应用场景建议使用bash；但python在文本处理方面的能力是shell无法比拟的； 编程语言：用于实现多种编程语言的链接，表现得像控制语言(胶水语言)，一种完备的编程语言； Web开发: web框架(Django、Flask等) 返回目录 Python的缺点 字节码: bytecode 如果与Java语言在类文件格式上统一的话，可以直接调用，或在JVM上执行； 因为不编译，python在执行效率上低于C/C++等语言； 返回目录 python语言执行流程 python解释器 CPython： 原始、标准的实现； Jython： Java实现的Python解释器； IronPython： .Net实现的Python解释器； 返回目录 python性能优化工具 PyPy，用python实现的python语言的动态编译器；执行效率极高； Shed Skin： Python编译器，能将Python代码转换成优化的C++代码； 返回目录 编写执行Python代码 交互式解释器； python程序文件： 交互式模式下的程序执行完成后难以再次执行； 写成程序文件的形式方便多次执行； python的类包含了一系列预编译好的语句的程序文件被称为“模块” 能够直接运行的模块文件通常被称为脚本，即程序的“顶层文件”。 返回目录 python程序可以分解成模块、语句、表达式和对象 程序由模块构成； 模块包含语句； 语句包含表达式； 表达式建立并处理对象： 表达式是“某事”，而语句是“做某事(即指令)\"; 语句的特性：他们改变了事物。例如，赋值语句改变了变量，print语句改变了屏幕输出等； 返回目录 python基础语法 在Linux上使用新版本的python 但切忌卸载原有版本；系统部分组件依赖于系统自带的python解释器； 1、编译安装新版本至某特定路径； 2、使用pyenv管理多版本并存，详见python编程环境准备； 编译安装Python: 需先安装gcc编译器； 下载python源代码； 下载ipython； tar xf python*.tar.gz ./config --help | more # 自行查看帮助信息； yum install readline-devel readline # 安装依赖； ./config --prefix=/usr/local/python27 make && make install /usr/local/python27/bin/python2.7 安装ipython： 下载源码； 解压； cd ipython /usr/local/pytho27/bin/python2.7 setup.py build /usr/local/pytho27/bin/python2.7 setup.py install 创建链接： ln -sv /usr/local/python27/bin/python2.7 /usr/bin/python27 ln -sv /usr/local/python27/bin/ipython /usr/bin/ipython 返回目录 数据结构 通过某种方式(例如对元素进行编号)组织在一起的数据元素的集合，这些数据元素可以是数字或者字符，甚至可以是其他的数据结构； python的最基本数据结构是序列； 序列中的每个元素被分配一个序号————即元素的位置，也称为索引；索引从0开始编号； python包含6种内建的数据序列：列表、元组、字符串、Unicode字符串、buffer对象和xrange对象； 返回目录 python的关键要素 基本数据类型； 对象引用 组合数据类型； 逻辑操作符 控制流语句； 算术操作符； 输入/输出 函数的创建与调用； 返回目录 内置函数 id(Var); 查看该对象引用的对象地址； type(Var); 返回指定对象的类型； dir([object]); --> list of strings; 返回目录 基本数据类型 Integral类型： 整型：不可变类型； 布尔型；True，False； 浮点类型： 浮点数； 复数； 十进制数字； 字符串: 不可变类型； 'GNU is Not Unix',字符串是序列； 返回目录 对象引用 python将所有数据存储为对象； python中，变量事实上是指向内存对象的引用； 动态类型：在任何时刻，只要需要，某个对象引用都可以重新引用一个不同的对象(可以是不同的数据类型) 内建函数type()用于返回给定数据项的数据类型； \"=\"用于将变量名与内存中的某个对象绑定：如果对象事先存在，就直接绑定；否则，则由\"=\"创建引用的对象； 返回目录 组合数据类型 数据结构： 通过某种方式(例如对元素进行编号)组织在一起的数据元素的集合； python常用的组合数据类型： 序列类型： 列表：使用[]创建，如['Call','me','Ishmeal','.'] 元组：使用()创建，如('one','two') 字符串：也属于序列类型，字符串使用引号，单、双、三都可以； 集合类型： 集合 映射类型： 字典； 列表是可变序列，元组是不可变序列； python中，组合数据类型也是对象，因此其可以嵌套； ['hello','world',[1,2,3]] 实质上，列表和元组并不真正存储数据，而是存放对内存对象的引用； python对象可以具有其可以被调用的特定\"方法(函数)\" 元组、列表以及字符串等数据类型是\"有大小的\",也即其长度(元素个数)，可使用内置函数len()测量； 返回目录 逻辑操作符 逻辑运算是任何程序设计语言的基本功能； python提供了4组逻辑运算： 身份操作符： is：判断左端对象引用是否相同于右端对象引用；也可以与None进行； In [2]: a = 10 In [3]: b = 5 In [4]: a is b Out[4]: False # a和b引用的是两个不同的内存对象； In [5]: print(id(a),id(b)) 9169824 9169664 In [6]: a = 10 In [7]: b = 10 In [8]: a is b Out[8]: True # a和b引用的是相同的内存对象； In [9]: print(id(a),id(b)) 9169824 9169824 In [12]: c = 15 In [14]: def test1(n): ...: if n == 1: ...: return None ...: else: ...: return True ...: In [15]: result = test1(1) In [16]: print(id(c),id(result)) 9169984 8892416 In [17]: print(c,result) 15 None In [18]: c is result Out[18]: False 比较操作符： , = , != , == , <> <>在python3中好像已经不支持了； 判断是否等于，必须使用== 成员操作符： in或not in： 测试成员关系；某个对象是否被包含于右端的对象中； In [10]: a = list(range(10)) In [11]: print(a) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] In [12]: 10 in a Out[12]: False # in 和 not in的结果是相反的； In [13]: 9 not in a Out[13]: False In [14]: 9 in a Out[14]: True 逻辑运算符： and，or，not In [16]: a = 3 In [17]: b = 5 In [19]: if b > a and b > 4: ...: print(\"b greater than 4\") ...: if a > 4 or b > 4: ...: print(\"at least,one of a,b is greater than 4\") ...: if not b > 10: ...: print(\"b is lesser than 10\") ...: b greater than 4 at least,one of a,b is greater than 4 b is lesser than 10 返回目录 控制流语句 控制流语句是过程式编程语言的基本控制机制； python的常见的控制流语句： if分支语句 The \"if\" statement ****************** The \"if\" statement is used for conditional execution: if_stmt ::= \"if\" expression \":\" suite ( \"elif\" expression \":\" suite )* [\"else\" \":\" suite] It selects exactly one of the suites by evaluating the expressions one by one until one is found to be true (see section *Boolean operations* for the definition of true and false); then that suite is executed (and no other part of the \"if\" statement is executed or evaluated). If all expressions are false, the suite of the \"else\" clause, if present, is executed. while循环语句 The \"while\" statement ********************* The \"while\" statement is used for repeated execution as long as an expression is true: while_stmt ::= \"while\" expression \":\" suite [\"else\" \":\" suite] This repeatedly tests the expression and, if it is true, executes the first suite; if the expression is false (which may be the first time it is tested) the suite of the \"else\" clause, if present, is executed and the loop terminates. A \"break\" statement executed in the first suite terminates the loop without executing the \"else\" clause's suite. A \"continue\" statement executed in the first suite skips the rest of the suite and goes back to testing the expression. for...in 循环语句： The \"for\" statement ******************* The \"for\" statement is used to iterate over the elements of a sequence (such as a string, tuple or list) or other iterable object: for_stmt ::= \"for\" target_list \"in\" expression_list \":\" suite [\"else\" \":\" suite] try语句： The \"try\" statement ******************* The \"try\" statement specifies exception handlers and/or cleanup code for a group of statements: try_stmt ::= try1_stmt | try2_stmt try1_stmt ::= \"try\" \":\" suite (\"except\" [expression [\"as\" identifier]] \":\" suite)+ [\"else\" \":\" suite] [\"finally\" \":\" suite] try2_stmt ::= \"try\" \":\" suite \"finally\" \":\" suite 返回目录 算术操作符 python提供了完整的算术操作符； 很多的python数据类型也可以使用增强的赋值运算符，如+=、-=等； 同样的功能，使用增强型赋值操作符的性能较好； python的int类型是不可变的，因此，增强型赋值的实际过程是创建了一个新的对象来存储结果后，将变量名执行了重新绑定； 返回目录 输入输出 现实中，具有实际功能的程序必须能够读取输入(如从键盘或文件中),以及产生输出，并写到终端或文件中； python的输入/输出: 输出： python3：print()函数； python2：print语句 输入： input() raw_input() # python3 中已经废弃，仅保留input(). python解释器提供了三种文件描述对象，分别为标准输入、标准输出和标准错误输出，他们在sys模块中分别以sys.stdin、sys.stdout和sys.stderr形式提供； python的print语句实现打印————一个对程序员友好的标准输出流接口； 从技术角度来讲，print是把一个或多个对象转换为其文本表达形式，然后返送给标准输出或另一个类似文件的流；————流式化； 在python中，打印与文件和流的概念联系紧密: 文件写入方法是把字符串写入到任意文件； print默认把对象打印到stdout流，并添加了一些自动的格式化； 实质上，print语句只是python的人性化特性的具体实现，它提供了sys.stdout.write()的简单接口，再加上一些默认的格式设置； print接受一个逗号分隔的对象列表，并为行尾自动添加一个换行符，如果不需要换行，则在最后一个元素后添加逗号； 返回目录 print格式化输出 #python2: print \"String %format1 %format2 ...\" % (variable1,variable2,...) #python3.5.2 In [12]: print(\"String %d %f %s\" % (12,3.14,\"guiyin.xiong\")) String 12 3.140000 guiyin.xiong In [13]: print(\"print test {num},{fot},{s}\".format(num=23,fot=3.14,s=\"guiyin.xiong\")) # 建议使用.format方法； print test 23,3.14,guiyin.xiong 返回目录 数据类型转换 隐式； 显式： dir(__builtins__): 查看所有的内置数据类型； help(str): 获取帮助； %后面可以使用的修饰符，(如果有，则只能按如下顺序)： %[(name)][flags][width][.precision]typecode name:位于括号中的一个属于后面的字典的键名，用于选出一个具体项； flags:下面标志中的一个或多个： -：表示左对齐； +：表示包含数字符号，正数也会带\"+\" 0：表示一个0填充； width:一个指定最小宽度的数字； 一个小数点，用于按照精度分隔字段的宽度； 一个数字，指定要打印字符串中的最大字符个数，浮点数中小数点之后的位数，或者整数的最小位数； 例子： d = {'x':32,'y':27.490325,'z':65} print \"%(x)-10d %(y)0.3g\" % d 返回目录 函数的创建与调用 函数是实现模块化编程的基本组件； python使用def语句定义函数； def functionName(arguments): suite 函数可以参数化，通过传递不同的参数来调用； 每个python函数都有一个返回值，默认为None，也可以使用\"return value\"明确定义返回值； def语句会创建一个函数对象，并同时创建一个指向该函数的对象引用； 函数也是对象，可以存储在组合数据类型中，也可以作为参数传递给其他函数； 内置函数callable()可用于测试对象是否可调用； 返回目录 python有众多内置函数 列出所有内置函数： In [6]: dir(__builtin__) dir(),help(),type(),len(),str(),id(),callable(); python标准库拥有众多内置模块，这些模块拥有大量函数； python模块实际上就是包含python代码的.py文件，其拥有自定义的函数与类及变量等； 导入模块使用import语句进行，后跟模块名称（不能指定模块文件名的后缀.py) 导入一个模块后，可以访问其内部包含的任意函数，类及变量； In [1]: import random In [3]: x = random.choice(['a','b','c','d','e','f']) In [4]: print x f 返回目录 编程习惯 变量的命名规则 只能包含字母、数字和下划线，且不能以数字开头 区分字母大小写； 禁止使用保留字； 以下划线开头的变量名在对python解释器有特殊意义； 返回目录 命名惯例 以单一下划线开头的变量名(_x)不会被from module import * 语句导入； 前后有双下划线的变量名(__x__)是系统定义的变量名，对python解释器有特殊意义； 以两个下划线开头，但结尾没有下划线的变量名(__x)是类的本地变量； 交互式模式下，变量名\"_\"用于保存最后一个表达式的结果； 注意：变量名没有类型，变量名引用的对象才有类型； 返回目录 Python编程风格 语句和语法： 注释： 单行注释使用#，可以从一行的任何地方开始； 续行： \\: ''': 三引号，闭合操作符，单一语句跨多行； 代码组： 缩进相同的一组语句构成的一个代码块 首行以关键字开始，如if、while等，以冒号结束； python使用缩进来分隔代码组，同一代码组的代码行必须严格左对齐，否则会造成语法错误； 同一行放置多个语句： 以分号(;)作为分隔符； 模块: 每一个Python脚本构建都可以被当成是一个模块； 模块里的代码可以是一段直接执行的脚本，也可以是一些类似库函数的代码从而可由 别的模块执行导入(import) # cat mod.py #!/usr/bin/python27 # def printName(a): print a b = \"Black\" print a + b b.py #!/usr/bin/python # import mod mod.printName(\"SSLinux\") 返回目录 标识符 标识符是计算机语言中允许作为名字的有效字符串集合； 其中有一部分是关键字，它们是语言的标识符，因此是保留字，不能用于其它用途； python还有称为\"内建\"的标识符集合，虽不是保留字，仍不推荐使用这些特别的名字； 返回目录 Python标识符 第一个字符只能使用字母或下划线； 余下的字符可以使用字母、数字或下划线； 区分字母大小写； 以下是python关键字： 返回目录 注释 注释：既不能缺少注释，亦要避免过度注释； 文档： Python允许通过__doc__动态获得文档字符串； print str.__doc__ 获取简要文档帮助； 缩进： 统一缩进4个字符串； 标识符名称要求：见名知意； Python风格指南： 英文：https://code.google.com/p/soc/wiki/PythonStyleGuide 译文：http://www.elias.cn/Python/PythonStyleGuide 返回目录 Python命名惯例 以单一下划线开头的变量名(_x)不会被from module import * 语句导入； 前后有双下划线的变量名(__x__)是系统变量名，对解释器有特殊意义； 以两个下划线开头、但结尾没有下划线的变量名(__x)是类的本地变量； 交互式模式下，只有单个下划线的变量名(_)用于保存最后一个表达式的结果； a = 'xyz' 实质相当于 a = str('xyz'): str是python内置的一个类，上述过程相当于使用str类实例化了一个对象(instance). 其他内置数据类型也是一样的，但内置数据类型的定义一般不使用\"a = str('xyz')的方式定义；\" 返回目录 Python文件主程序 主程序： 无论当前模块是被别的模块导入还是作为脚本直接执行，都会执行这部分代码； 注意：所有的模块都有能力执行代码； 最高级别的python语句(没有缩进的)在模块被导入时就会执行，无论是否真的需要执行； 妥当的做法： 除了那些真正需要执行的代码以外，所有的功能代码都通过函数建立，因此： 仅在主程序模块中编写大量的可执行代码； 用于被导入的模块只应该存在较少的顶级代码； 内置变量：__name__，指示模块应该如何被加载： 如果模块被导入，__name__的值是模块自己的名字； 如果模块是直接执行，__name__的值是'__main__' 每个模块都有一个名为__name__的内建变量，此变量值会根据调用此模块的方式发生变化： 如果此文件被作为模块导入，则__name__的值为模块名称； 如果此文件被直接执行，则__name__的值为\"__main__\". 因此: 在被导入的模块中常会有以下方式的写法，主要是为了方便测试： if __name__ == '__main__': if_suit Copyright && Guiyin.Xiong From ==>> notebook.sslinux.com all right reserved，powered by Gitbook2017年6月12日 2017-09-20 16:37:48 "},"Python/02BuiltinTypes.html":{"url":"Python/02BuiltinTypes.html","title":"02.Built-in Types","keywords":"","body":"目录 Python内置类型 Python对象的相关术语 对象的身份与类型 两个对象的三种属性比较 Python核心数据类型 数字:int,long,float,complex,bool str unicode list dict tuple file set 其他类型 编程单元类型 与实现相关的类型 其他文件类工具 类型转换 str(),repr()或format()：将非字符型数据转换为字符； int():转换为整数； float():转换为浮点数； list(s): 将字串s转换为列表； tuple(s):将字串转换为元组； set(s): 将字串s转换为集合； frozenset(s)：将字串s转换为不可变集合； dict(d): 根据指定的键值对，创建字典，d必须是(key,value)的元组序列； chr(x): 将整数转换为单个字符； ord(x): 将字符转换为整数值； hex(x): 将整数转换为16进制字符； bin(x): 将整数转换为2进制字符； oct(x): 将整数转换为8进制字符； 数字类型 序列类型 字符类型 适用于所有序列的操作和方法 运算符 内置函数-对象的自有的方法 适用于字符串的操作 适用于可变序列的操作 适用于列表的方法 python内置库copy 元组 元组常见操作 映射类型 dict 字典内置方法 简单回顾 如何获取使用帮助 集合是一组无序排列的可hash的值 集合类型的方法和操作 集合操作 容器类型对象 Python内置类型 Python对象的相关术语 Python程序中保存的所有数据都是围绕对象这个概念展开的： 程序中存储的所有数据都是对象； 每个对象都有一个身份、一个类型和一个值； 例如：school=\"MaGe Linux\"会以\"MaGe Linux\"创建一个字符串对象，其身份是指向它在内存中所处位置的指针(其在内存中的地址),而school就是引用这个具体位置的名称。 对象的类型也称对象的类别，用于描述对象的内部表示及它支持的方法和操作； 创建特定类型的对象时，有时也将该对象称为该类型的实例； 实例被创建后，其身份和类型就不可改变； 如果对象值是可改变的，则称为可变对象； 如果对象值是不可改变的，则称为不可变对象； 如果某个对象包含对其他对象的引用，则将其称为容器； 大多数对象都拥有大量特有的数据属性和方法： 属性：与对象相关的值； 方法：被调用时将在对象上执行某些操作的函数； 使用点(.)号运算符可以访问对象的属性和方法； 名词 解释 class 在自定义类型时使用； type 类型. instance 实例化； 类：数据和方法组成； 数据：变量； 方法：函数； 类：实例化成对象； CA： IA： IB： 返回目录 对象的身份与类型 Python内置函数id()可返回一个对象的身份，即该对象在内存中的位置； is运算符用于比较两个对象的身份； type()用于返回一个对象的类型； 对象类型本身也是一个对象，称为对象的类； 该对象的定义是唯一的，且对于某类型的所有实例都是相同的； 所有类型对象都有一个指定的名称，可用于执行类型检查，如list,dict if a is b: # 身份比较； statements if a == b: # 值比较； statements if type(a) is type(b): # 类型比较； statements 返回目录 两个对象的三种属性比较 1、值比较：对象中的数据是否相同； num1 == num2 2、身份比较：两个变量名引用是否为同一对象； num1 is num2 3、类型比较：两个对象的类型是否相同； type(num1) is type(num2) 返回目录 Python核心数据类型 数字:int,long,float,complex,bool 3077，3.14，300000 int long float complex bool str unicode 'mageedu.com',\"spam\" list ['one','two','three'] dict {'course':'linux','language':'python'} tuple (32,'spam','eggs') file myFile=open('/tmp/tfile','r') set set,frozenset(冻结集合) set('abc'),{'a','b','c'} 其他类型 类类型，None，布尔型； 编程单元类型 函数、模块、类 与实现相关的类型 编译的代码堆栈跟踪； 其他文件类工具 pipes fifos sockets 返回目录 类型转换 str(),repr()或format()：将非字符型数据转换为字符； str1 = repr(num1) int():转换为整数； float():转换为浮点数； list(s): 将字串s转换为列表； tuple(s):将字串转换为元组； set(s): 将字串s转换为集合； frozenset(s)：将字串s转换为不可变集合； dict(d): 根据指定的键值对，创建字典，d必须是(key,value)的元组序列； chr(x): 将整数转换为单个字符； ord(x): 将字符转换为整数值； hex(x): 将整数转换为16进制字符； bin(x): 将整数转换为2进制字符； oct(x): 将整数转换为8进制字符； 返回目录 数字类型 库： numpy：科学运算相关； math：数学相关的运算； python的数字字面量：布尔型，整数，浮点数，复数； 布尔型： True：1 False：0 数字类型的算术运算： x + y 加法 x - y 减法 x * y 乘法 x / y 除法 x // y 截断除法 x ** y 乘方； x % y 取模(x mod y) -x 一元减法(负数) +x 一元加法(正数) 位移运算： 正数： 向左移，数字增大； 向右移，数字变小； x > y 右移 x & y 按位与 x | y 按位或 x ^ y 按位抑或 ~x 按位求反 返回目录 序列类型 序列类型表示索引为非负整数的有序对象集合，包括字符串、列表和元组； 字符串是字符的序列； 列表和元组是任意python对象的序列； 字符串和元组属于不可变序列，而列表则支持插入、删除和替换元素； 所有序列都支持迭代； 返回目录 字符类型 字符串字面量：把文本放入单引号、双引号、三引号中；三(单|双)引号可以实现跨行定义； 如果要使用unicode编码，则在字符之前使用字符u进行标识，如: u\"magedu.com\" 文档字串：模块、类或函数的第一条语句是一个字符串的话，该字符串就成为文档字符串，可以通过__doc__变量引用； In [14]: def printName(): ...: \"test function\" ...: print \"Hello,sslinux.com\" ...: In [15]: printName() #使用括号()运算符，表示调用函数； Hello,sslinux.com In [16]: printName().__doc__ # 函数的内置属性，调用函数的开头说明文档； Hello,sslinux.com In [17]: printName.__doc__ #不适用括号运算符()表示调用函数对象本身； Out[17]: 'test function' 返回目录 适用于所有序列的操作和方法 运算符 s[i]: 索引运算符； s[i:j]: 为切片运算符； s[i:j:stride] 为扩展切片运算符； 切片运算，切片后的结果会生成新对象； 内置函数-对象的自有的方法 min(s)和max(x)，只适用于能够对元素排序的序列；按ASCII码排序； sum(s)只适用于数字序列；求各项之和； all(s) 检查序列中的各项是否都为True；只要有一项为False就为False； len(s) 序列s中的元素个数； any(s) 检查序列s中的任意项是否为true；只要又一项为True就为True； 返回目录 适用于字符串的操作 Python2 提供两种字符串对象类型： 字节字符串：字节(8bit数据)序列； Unicode字符串：Unicode字符(16bit数据)序列； Python可以使用32 bit整数保存Unicode字符，但此为可选特性； s.captitalize() 首字符变大写； s.index(sub [, start [,end]]) 找到指定字符串sub首次出现的位置，否则报错； s.join(t) 使用s作为分隔符,连接序列t中的字符串； In [18]: str1 = \"www.sslinux.com\" In [19]: l1 = list(str1) In [20]: print l1 ['w', 'w', 'w', '.', 's', 's', 'l', 'i', 'n', 'u', 'x', '.', 'c', 'o', 'm'] In [21]: ''.join(l1) Out[21]: 'www.sslinux.com' s.lower() 转换为小写形式； s.upper() 将一个字符串转换为大写形式； s.replace(old,new [,maxreplace]) 替换一个子字符串； s.split([sep [,maxaplit]]) 使用sep作为分隔符对一个字符串进行划分。maxsplit是划分的最大次数； s.strip([chrs]) 删掉chrs开头和结尾的空白或指定字符； 返回目录 适用于可变序列的操作 s[i] = v 元素赋值； s[i:j] = t 切片赋值； s[i:j:stride] = t 扩展切pain赋值； del s[i] 元素删除； del s[i:j] 切片删除； del s[i:j:stride] 扩展切片删除； 返回目录 适用于列表的方法 容器类型： 任意对象的有序集合，通过索引访问其中的元素，可变对象； 异构，任意嵌套； l2 = [1,'b'] l3 = [[1,2],['a','b']] 支持在原处修改；修改的是元素的引用； 修改操作包括： 修改指定的索引元素，修改指定的分片，删除语句，内置方法； l2[1:3] = [] # 指定分片的元素将会被删除； list(s)可将任意可迭代类型转换为列表，而如果s已经是一个列表，则该函数构造的新列表是s的一个浅复制； list(s) 将s转换为一个列表； s.append(x) 将一个新元素x追加到s末尾； s.extend(t) 将一个新列表t追加到s末尾；合并两个列表中的元素； s.count(x) 计算s中元素x的出现次数； s.index(x[,start[,stop]]) 返回指定元素在列表中首次出现的索引号，可选参数start,stop用于指定搜索的起始和结束索引； s.insert(i,x) 在索引i处插入x，元素占用原来索引i的位置； s.pop([i]) 返回索引i所在位置的元素，并从列表中移除该元素。如果省略i，则返回列表中最后一个元素并移除；选择并且不重复的场景可使用。 s.remove(x) 搜索元素x并从s中移除它 s.reverse() 颠倒s中的所有元素的顺序；在原处修改，无返回值； s.sort([key [,reverse]]) 对s中的所有元素进行排序。key是一个键函数。reverse是一个标志，表明是否以倒序对列表进行排序。key和reverse应该始终以关键字参数的形式指定； l1 + l2: 合并两个列表，返回一个新的列表；不会修改原有列表；字符串也一样； l1 * N ：把l1重复N次，返回一个新列表；字符串也支持； in操作符：成员关系判断符；判断在指定容器中是否出现了指定元素；返回Bool值； 用法：obj in container not in: 成员关系判断； obj not in container 内置函数range： 返回一个range对象； l1 = range(10) 列表解析：[i**2 for i in range(1,10) if i % 2 == 1] 列表赋值特殊情况： In [1]: l1 = [1,2,3] In [2]: l2 = l1 # l1 和 l2 指向了同一个内存对象； In [3]: l1.append(4) In [5]: print(l1) [1, 2, 3, 4] In [6]: print(l2) [1, 2, 3, 4] 要想在赋值时生成新的列表，应该使用： l3 = l1[:]; 相当于将l1的所有元素复制了一份给l3,深复制(copy.deepcopy)； 返回目录 python内置库copy import copy 列表复制方式： l1 = [1,2,3,4] # 浅复制； l2 = l1 import copy l2 = copy.deepcopy(l1) # 深复制； l2 = l1[:] 返回目录 元组 表达式符号；() 容器类型： 任意对象的有序集合，通过索引访问其中的元素，不可变对象，长度固定； 支持异构，迭代； In [7]: t1 = (1,2,3,4) In [8]: t1.count(3) # 对象在元组中出现的次数； Out[8]: 1 In [9]: t1.index(2) # 查询对象在元组中的索引； Out[9]: 1 In [10]: t1.count(10) Out[10]: 0 In [11]: t1.index(15) # 如果对象不存在于元组中，抛出异常，应该先使用in判读一下对象是否存在于元组中； --------------------------------------------------------------------------- ValueError Traceback (most recent call last) in () ----> 1 t1.index(15) ValueError: tuple.index(x): x not in tuple 返回目录 元组常见操作 () : 定义空元组； 相当于 t1 = () t1 = tuple() 切片，返回的是新元组； 定义元组时，小括号()可省略，t1 = 1,2,3,4，建议尽量不要省略，以免造成歧义； 加法运算(t1 + t2)：合并两个元组，生成新元组； 乘法运算(t1 * N)：重复元组元素N次，生成新元组； 'x' in t4 : 成员关系判断； 虽然元组本身不可变，但如果元组内嵌套了可变类型的元素(如:列表等)，那么此类元素的修改不会返回新元组； 例如： In [13]: t1 = ('x',[1,2,3]) In [14]: id(t1) Out[14]: 70619904 In [15]: type(t1) Out[15]: tuple In [16]: t1[1] Out[16]: [1, 2, 3] In [17]: t1[1].pop() Out[17]: 3 In [19]: print(t1[1]) [1, 2] In [20]: print(t1) ('x', [1, 2]) In [21]: id(t1) # 元组t1的id还是没有变哦。 Out[21]: 70619904 返回目录 映射类型 映射类型表示一个任意对象的集合，而且可以通过另一个几乎是任意键值的集合进行索引； 与序列不同，映射是无序的，它通过键进行索引； 任意不可变对象都可用作字典的键，如字符串、数字、元组等； 包含可变对象的列表、字典和元组不能用作键； m[k]运算符用于选择映射对象中的一项，其中'k'是一个键： 引用不存在的键会引发KeyError异常； 返回目录 dict 字典在其他编程语言中又称作关联数组或散列表； dict特性： 通过键来实现元素存取； 无序集合； 可变类型容器，长度可变； 支持异构，支持嵌套； {key1:value1,key2:value2,....} {}：空字典； len(d1):返回字典元素个数； 返回目录 字典内置方法 d1.clear: #清除其中的所有元素； d2 = d1.copy(): #字典复制；深复制； dict.get() : #返回指定键的值； dict.haskey(): #判断字典是否有指定键； dict.items(): #将字典转换为元组列表的形式； dict.keys(): #返回键列表； dict.values(): #返回值列表； dict.pop(): #弹出指定键的元素，并返回该键的值； dict.popitem(): #随机弹出键值映射； dict.update(d1): #合并两个字典，若两个字典中键有重复，以d1为结果； dict.iteritem: #返回一个键值对迭代器对象；可以使用next()方法。py3中无； dict.iterkeys: #返回一个键迭代器对象；py3: dict.keys() dict.itervalue: #返回一个值的迭代器对象； dict.viewitems: #返回键值对所拆分的元组； dict.viewkeys: #返回键列表； dict.viewvalues: #返回值列表； zip()函数：返回以元组为元素的列表； 可以使用zip()帮助生成dict； In [23]: dict(zip('xyz','123')) Out[23]: {'x': '1', 'y': '2', 'z': '3'} 字典的键必须是可hash的；一般为字符或数字； 类：数据 + 方法 实例： 3 + 5 3.__add__(5) 列表和字典： 变量名：仅仅是指向对象的引用； 对象：实际存储在内存中； 点号运算符： 属性：数据； 返回一个数据，显示则要使用print语句或函数； 方法：操作；() 调用：执行一段代码； 可调用对象，判断对象是否可调用：内置函数callable() 返回目录 简单回顾 字串： str() 单引号：'' 双引号：\"\" 三个单引号：''',''' 三个双引号：\"\"\" \"\"\" 元组: (),tuple() 列表: [],list() 字典: {},dict() 数值：int() 返回目录 如何获取使用帮助 获取对象支持使用的属性和方法：dir() 某方法的具体使用帮助：help() : help(list.pop) 获取可调用对象的文档字串：print(obj.__doc__) 返回目录 集合是一组无序排列的可hash的值 支持集合关系测试： 并集，交集，差集 支持成员关系测试： in， not in， 迭代， 不支持：索引、元素获取、切片； 集合的类型：set()、frozenset() 没有特定语法格式，只能通过工厂函数创建； help(set) s1 = set() s1 = set(一个可迭代对象) 返回目录 集合类型的方法和操作 len(s) 返回s中项目数； s.copy() 制作s的一份副本； s.difference(t) 求差集，返回所有在s中，但不再t中的项目； s.intersection(t) 求交集。返回所有同时在s和t中的项目； s.isdisjoint(t) 如果s和t没有相同项，则返回True； s.issubset(t) 如果s是t的一个子集，则返回True； s.issuperset(t) 如果s是t的一个超集，则返回True； s.symmetric_difference(t) 求对称差集。返回所有在s或t中，但又不同时在这两个集合中的项求并集。返回所有在s或t中的项； s.union(t) 求并集。返回所有在s或t中的项； s.pop() 弹出元素； s.update(s3) 将可hash对象合并为一个集合； s.add() 往集合中加入一个元素； 返回目录 集合操作 s | t # s和t的并集 s & t # s和t的交集 s - t # 求差集； s ^ t # 求对称差集； len(s) # 集合中项数 max(s) # 最大值 min(s) # 最小值； frozenset(): 冻结集合，不可变集合；与set()类似，但修改操作无效； 返回目录 容器类型对象 1、列表、元组、字典字面量可在不使用续行符的情况下跨行定义，最后一个元素后面可以使用逗号，为空的情况下不可以使用逗号； 2、所有对象都有引用计数，为某个对象指定新名称或将某个对象放入容器中，都会增加该对象的引用计数；当引用计数为0时，垃圾回收器就可以在后台将对象回收； 查看对象的当前引用计数： import sys name = \"sslinux\" sys.getrefcount(name) 3、列表和字典都支持两种类型的复制操作：浅复制和深复制； 深复制可使用copy模块中的deepcopy()方法复制； 4、Python中的所有对象都是\"第一类的\"，这意味着使用标识符命名的所有对象都具有相同状态，于是，能够命名的所有对象都可以直接当数据进行处理； 5、所有序列都支持迭代； 6、所有序列都支持的操作和方法： s[i] s[i:j] s[i:j:stride] len(s) min(s) max(s) sum(s) all(s) any(s) s1 + s2: 连接 s1 * N: 重复 obj in s1 : 成员关系判断； obj not in s1: 成员关系判断； 7、可变序列的操作： s1[index] = value 元素赋值； s1[i:j] = t 切片赋值； del s1[index] 删除指定元素； del s1[i:j] 删除切片； del s1[i:j:stride] 删除扩展切片； 返回目录 Copyright && Guiyin.Xiong From ==>> notebook.sslinux.com all right reserved，powered by Gitbook2017年6月12日 2017-09-20 16:37:48 "},"Golang/Golang.html":{"url":"Golang/Golang.html","title":"二、Golang","keywords":"","body":"二、Golang 00.Go安装 01.GOPATH与工作空间 00.Go安装 01.GOPATH与工作空间 Copyright && Guiyin.Xiong From ==>> notebook.sslinux.com all right reserved，powered by Gitbook2017年6月12日 2017-09-20 16:37:48 "},"Golang/00Installation.html":{"url":"Golang/00Installation.html","title":"00.Installation","keywords":"","body":"安装Go 安装Go的多种方式 Go源码安装 二进制安装 Mac系统安装 Windows系统安装 第三方安装工具 GVM GVM Requirements Mac OS X Requirements Linux Requirements FreeBSD Requirements apt-get wget homebrew 安装Go的多种方式 Go的三种安装方式 源码安装 Go标准包安装 第三方工具安装，如：apt-get，wget，homebrew，yum； GVM，Go多版本管理工具； 返回目录 Go源码安装 Go1.5彻底移除C代码，Runtime、Compiler、Linker均由Go编写，实现自举。(安装了上一个版本，即可从源码安装). 在Go1.5前，Go的源代码中，有些部分是用Plan 9 C和AT&T汇编写的，因此假如你要想从源码安装，就必须安装C的编译工具。 系统 条件 Mac Xcode包含了相应的编译工具 Unix-Like 需要安装gcc等工具，sudo apt-get install gcc libc6-dev Windows|安装MinGW，通过MinGW安装GCC，并设置相应的环境变量| 源码编译安装步骤： 去官网下载源码,选择相应版本； 解压并且编译； $ wget https://codeload.github.com/golang/go/tar.gz/go1.4.2 $ tar xf go-go1.4.2.tar.gz $ ln -sv go-go1.4.2 golang 'golang' -> 'go-go1.4.2' $ ls -ld golang lrwxrwxrwx 1 kalaguiyin kalaguiyin 10 6月 14 09:02 golang -> go-go1.4.2 # 进入go源码目录进行编译； $ cd golang/src/ ~/Downloads/golang/src$ ./all.bash # 运行all.bash后出现\"ALL TESTS PASSED\"字样是才算成功。 # Windows类似，只不过运行的是all.bat,调用的编译器是MinGW的gcc。 设置环境变量，写入文件(.bashrc或.zshrc)永久有效； export GOPATH=$HOME/Golang_Source/ export PATH=$PATH:$HOME/go/bin:$GOPATH/bin 使得配置文件生效： source ~/.bashrc 或 source ~/.bashrc bash ~/.bashrc 或 . ~/.bashrc 从1.8开始，GOPATH环境变量就有一个默认值： 在Unix-Like上的默认值为$HOME/go; 在Windows上的默认值为%USERPROFILE%/go; 返回目录 二进制安装 Go提供了每个平台打包好的一键安装，默认会安装到如下目录： /usr/local/go(Unix-Like) C:\\Go(Windows) 安装完成后需要设置环境变量： export GOROOT=$HOME/go export GOPATH=$HOME/gopath export PATH=$PATH:$GOROOT/bin:$GOPATH/bin # Unix-Like 用户写入 .bashrc 或者 .zshrc 文件，Windows用户写入环境变量； 判断系统是32位还是64位： Windows： Win + R运行cmd，运行systeminfo命令； Unix-Like： arch 或 uname -m 返回目录 Mac系统安装 下载二进制包(goVERSION.darwin-*.pkg),一路下一步，默认在PATH中增加了相应的~/go/bin ; 执行go命令验证是否安装成功； 返回目录 Windows系统安装 不建议修改默认安装路径； 默认会在黄江变量PATH后添加Go安装目录下的bin目录——C:\\Go\\bin\\, 并添加环境变量GOROOT，值为Go安装根目录C:\\Go 。 返回目录 第三方安装工具 GVM GVM是第三方开发的Go多版本管理工具，类似ruby里面的rvm工具； 安装： bash 返回目录 GVM Requirements Mac OS X Requirements Install Mercurial from https://www.mercurial-scm.org/downloads Install Xcode Command Line Tools from the App Store. xcode-select --install brew update brew install mercurial Linux Requirements Debian/Ubuntu sudo apt-get install curl git mercurial make binutils bison gcc build-essential Redhat/Centos sudo yum install curl sudo yum install git sudo yum install make sudo yum install bison sudo yum install gcc sudo yum install glibc-devel Install Mercurial from http://pkgs.repoforge.org/mercurial/ FreeBSD Requirements sudo pkg_add -r bash sudo pkg_add -r git sudo pkg_add -r mercurial 返回目录 apt-get Debian系列的Linux系统上使用apt-get命令安装，同时将git和mercurial也装上： sudo apt-get install python-software-properties sudo add-apt-repository ppa:gophers/go sudo apt-get update sudo apt-get install golang-stable git-core mercurial 返回目录 wget wget https://storage.googleapis.com/golang/go1.8.1.linux-amd64.tar.gz sudo tar -xzf go1.8.1.linux-amd64.tar.gz -C /usr/local 配置环境变量： $ sudo vim /etc/profile export GOROOT=/usr/local/go export GOBIN=$GOROOT/bin export PATH=$PATH:$GOBIN export GOPATH=$HOME/gopath (可选设置) 重新加载profile文件： source /etc/profile 返回目录 homebrew homebrew是Mac系统下面目前使用最多的管理软件的工具，目前已支持Go，可以通过命令直接安装Go，为了方便，建议把git和mercurial也装上； 1.安装homebrew： /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/maste r/install)\" 2.安装Gobrew update && brew upgrade brew install go brew install git brew install mercurial //可选安装 返回目录 Copyright && Guiyin.Xiong From ==>> notebook.sslinux.com all right reserved，powered by Gitbook2017年6月12日 2017-09-20 16:37:48 "},"Golang/01GOPATH与工作空间.html":{"url":"Golang/01GOPATH与工作空间.html","title":"01.GOPATH and WORKSPACE","keywords":"","body":"GOPATH与工作空间 GOPATH与工作空间 GOPATH设置 代码目录结构规划 编译应用 获取远程包 GOPATH与工作空间 Golang需要设置GOPATH环境变量； Go从1.1版本到1.7必须设置GOPATH这个变量，而且不能和Go的安装目录一样； 用途：用来存放Go源码，Go的可执行文件，以及相应的编译之后的包文件； 这个目录下面有三个子目录：src、bin、pkg 从go1.8开始，GOPATH有默认值。在Unix上默认为$HOME/go,在windows上默认为%USERPROFILE%/go 。 GOPATH设置 # Unix-Like: $ vim ~/.bashrc export GOPATH=$HOME/gopath # Windows新建环境变量GOPATH： GOPATH=C:\\gopath GOPATH允许多个目录，当有多个目录时，请注意分隔符： Windows是分号； Linux是冒号； 当有多个GOPATH时，默认会讲go get的内容放在第一个目录下； $GOPATH目录约定有三个子目录： src 存放源代码(比如: .go .c .h .s等) pkg 编译后生成的文件(比如: .a) bin 编译后生成的可执行文件； 为了方便，可以把此目录加入到$PATH变量中，如果有多个gopath，那么使用${GOPATH//://bin:}/bin添加所有的bin目录； 代码目录结构规划 GOPATH下的src目录就是接下来开发程序的主要目录，所有的源码都是放在这个目录下面，我们一般的做法是一个目录一个项目； 例如: $GOPATH/src/mymath 表示mymath这个应用包或者可执行应用,这个根据package是main还是其他来决定,main的话就是可执行应用,其他的话就是应用包。 所以当新建应用或者一个代码包时都是在src目录下新建一个文件夹,文件夹名称一般是代码包名称,当然也允许多级目录,例如在src下面新建了目录$GOPATH/src/github.com/astaxie/beedb 那么这个包路径就是\"github.com/astaxie/beedb\",包名称是最后一个目录beedb 下面我就以mymath为例来讲述如何编写应用包,执行如下代码： [root@pythonenv src]# cat mymath/sqrt.go //$GOPATH/src/mymath/sqrt.go源码如下： package mymath func Sqrt(x float64) float64 { z := 0.0 for i :=0; i 这样我的应用包目录和代码已经新建完毕,注意:一般建议package的名称和目录名保持一致. 编译应用 上面我们已经建立了自己的应用包，如何进行编译安装呢？有两种方式可以进行安装： 1、只要进入对应的应用包目录，然后执行go install，就可以安装了； 2、在任意的目录执行 go install mymath # 确认环境变量及目录结构； [root@pythonenv src]# echo $GOPATH /root/gopath [root@pythonenv src]# tree $GOPATH /root/gopath ├── bin ├── pkg └── src └── mymath └── sqrt.go 4 directories, 1 file # 编译包； [root@pythonenv src]# cd $GOPATH/src/mymath [root@pythonenv mymath]# pwd /root/gopath/src/mymath [root@pythonenv mymath]# go install 安装完成后，我们可以进入如下目录： cd $GOPATH/pkg/${GOOS}_${GOARCH} 可以看到编译生成的包文件； [root@pythonenv mymath]# tree /root/gopath/ /root/gopath/ ├── bin ├── pkg │ └── linux_amd64 │ └── mymath.a # 应用包文件；被调用； └── src └── mymath └── sqrt.go 5 directories, 2 files 这个.a文件是应用包,那么我们如何进行调用呢? 接下来我们新建一个应用程序来调用这个应用包 新建应用包mathapp [root@pythonenv mymath]# cd $GOPATH/src [root@pythonenv src]# mkdir mathapp [root@pythonenv src]# cd mathapp [root@pythonenv mathapp]# vim main.go [root@pythonenv mathapp]# cat main.go # $GOPATH/src/mathapp/main.go源码： package main import ( \"mymath\" \"fmt\" ) func main() { fmt.Printf(\"Hello,World. Sqrt(2) = %v\\n\",mymath.Sqrt(2)) } 在这个文件中： package是main，import里面调用的是mymath，这个就是相对于$GOPATH/src的路径； 如果是多级目录，就在import里面引入多级目录； 如果你有多个GOPATH，也是一样，Go会自动在多个$GOPATH/src中寻找。 如何编译？ # 切换目录到源代码所在路径： [root@pythonenv mathapp]# cd $GOPATH/src/mathapp [root@pythonenv mathapp]# ls main.go [root@pythonenv mathapp]# go build [root@pythonenv mathapp]# ls main.go mathapp # 编译生成可执行文件：mathapp [root@pythonenv mathapp]# ./mathapp Hello,World. Sqrt(2) = 1.414213562373095 [root@pythonenv mathapp]# ls $GOPATH/bin/ # go install 则可以将编译生成的可执行文件安装到$GOPATH/bin目录下； [root@pythonenv mathapp]# go install [root@pythonenv mathapp]# ls $GOPATH/bin/ mathapp 获取远程包 go语言有一个获取远程包的工具就是 go get ,目前go get支持多数开源社区(例如:github、googlecode、bitbucket、Launchpad) go get github.com/astaxie/beedb go get -u 参数可以自动更新包，而且当go get的时候会自动获取该包依赖的其他第三方包。 通过这个命令可以获取相应的源码,对应的开源平台采用不同的源码控制工具,例如github采用git、 googlecode采用hg,所以要想获取这些源码,必须先安装相应的源码控制工具。 Copyright && Guiyin.Xiong From ==>> notebook.sslinux.com all right reserved，powered by Gitbook2017年6月12日 2017-09-20 16:37:48 "},"JavaScript/JavaScript.html":{"url":"JavaScript/JavaScript.html","title":"三、JavaScript","keywords":"","body":"三、JavaScript Copyright && Guiyin.Xiong From ==>> notebook.sslinux.com all right reserved，powered by Gitbook2017年6月12日 2017-09-20 16:37:48 "},"NodeJS/NodeJS.html":{"url":"NodeJS/NodeJS.html","title":"四、NodeJS","keywords":"","body":"四、NodeJS Copyright && Guiyin.Xiong From ==>> notebook.sslinux.com all right reserved，powered by Gitbook2017年6月12日 2017-09-20 16:37:48 "},"DevOps/DevOps.html":{"url":"DevOps/DevOps.html","title":"五、DevOps","keywords":"","body":"五、DevOps 01BtrFS文件系统 01BtrFS文件系统 Copyright && Guiyin.Xiong From ==>> notebook.sslinux.com all right reserved，powered by Gitbook2017年6月12日 2017-11-30 14:33:16 "},"DataBase/DataBase.html":{"url":"DataBase/DataBase.html","title":"六、DataBase","keywords":"","body":"六、DataBase Copyright && Guiyin.Xiong From ==>> notebook.sslinux.com all right reserved，powered by Gitbook2017年6月12日 2017-09-20 16:37:48 "},"Commands/Commands.html":{"url":"Commands/Commands.html","title":"七、Commands","keywords":"","body":"七、Commands Copyright && Guiyin.Xiong From ==>> notebook.sslinux.com all right reserved，powered by Gitbook2017年6月12日 2017-09-20 16:37:48 "},"OSS/OSS.html":{"url":"OSS/OSS.html","title":"八、OSS","keywords":"","body":"八、OSS Copyright && Guiyin.Xiong From ==>> notebook.sslinux.com all right reserved，powered by Gitbook2017年6月12日 2017-09-20 16:37:48 "},"Interview/Interview.html":{"url":"Interview/Interview.html","title":"九、Interview","keywords":"","body":"Interview Nginx Tegine lua Openresty awk Shell Docker k8s Ansible Copyright && Guiyin.Xiong From ==>> notebook.sslinux.com all right reserved，powered by Gitbook2017年6月12日 2017-09-20 16:37:48 "},"Interview/Nginx.html":{"url":"Interview/Nginx.html","title":"Nginx","keywords":"","body":"Nginx 官方资源 官方资源 Nginx官网 Nginx文档 Copyright && Guiyin.Xiong From ==>> notebook.sslinux.com all right reserved，powered by Gitbook2017年6月12日 2017-09-20 16:37:48 "},"Interview/Tengine.html":{"url":"Interview/Tengine.html","title":"Tengine","keywords":"","body":"Tengine 官网资源 Tengine官网 Tengine Download Tengine Source Code Tengine Documentation Copyright && Guiyin.Xiong From ==>> notebook.sslinux.com all right reserved，powered by Gitbook2017年6月12日 2017-09-20 16:37:48 "},"Interview/lua.html":{"url":"Interview/lua.html","title":"Lua","keywords":"","body":"Lua 官方资源 lua官网 lua doc Copyright && Guiyin.Xiong From ==>> notebook.sslinux.com all right reserved，powered by Gitbook2017年6月12日 2017-09-20 16:37:48 "},"Interview/Openresty.html":{"url":"Interview/Openresty.html","title":"Openresty","keywords":"","body":"Openresty 官方资源 Openresty英文官网 Openresty中文官网 Openresty Github Copyright && Guiyin.Xiong From ==>> notebook.sslinux.com all right reserved，powered by Gitbook2017年6月12日 2017-09-20 16:37:48 "},"Interview/awk.html":{"url":"Interview/awk.html","title":"awk","keywords":"","body":"awk The GNU Awk User’s Guide Copyright && Guiyin.Xiong From ==>> notebook.sslinux.com all right reserved，powered by Gitbook2017年6月12日 2017-09-20 16:37:48 "},"Interview/shell.html":{"url":"Interview/shell.html","title":"shell","keywords":"","body":"shell Copyright && Guiyin.Xiong From ==>> notebook.sslinux.com all right reserved，powered by Gitbook2017年6月12日 2017-09-20 16:37:48 "},"Interview/docker.html":{"url":"Interview/docker.html","title":"docker","keywords":"","body":"docker Docker官网 Docker Community Edition Docker Enterprise Edition Docker Docs Docker Store Copyright && Guiyin.Xiong From ==>> notebook.sslinux.com all right reserved，powered by Gitbook2017年6月12日 2017-09-20 16:37:48 "},"Interview/k8s.html":{"url":"Interview/k8s.html","title":"k8s","keywords":"","body":"k8s kubernetes官网 kubernetes官网 kubernetes Documentation Copyright && Guiyin.Xiong From ==>> notebook.sslinux.com all right reserved，powered by Gitbook2017年6月12日 2017-09-20 16:37:48 "},"Interview/Ansible.html":{"url":"Interview/Ansible.html","title":"Ansible","keywords":"","body":"Ansible Ansible官方资源 Ansible特性 安装及程序环境 程序 配置文件 主机清单 插件目录 安装ansible ansible命令的使用 Usage: ansible host-pattern [options] 常用选项： 配置Host Inventory /etc/ansible/hosts 添加两台主机做测试用 SSH免密码登录设置 生成私钥和公钥 复制公钥文件为authorized_keys 把公钥传送到其他主机 在被控制端主机查看密钥并确认其权限 使用ansible的ping模块测试两台主机的连通性 同步主机之间的时间以免造成日志混乱 ansible模块 获取模块列表 获取指定模块的使用帮助 ansible-doc -s MOD_NAME 常用模块 ping模块：探测目标主机是否存活； command模块：在远程主机执行命令，是Ansible的默认模块； shell模块：在远程主机上调用shell解释器运行命令，支持shell的各种特性，例如管道、重定向等； 注意：command和shell模块的核心参数直接为命令本身；而其他模块的参数通常为\"key=value\"格式； copy模块：复制文件到远程主机 file模块：设置文件的属性 fetch模块：从远程主机拿文件 cron模块：管理计划任务条目； hostname模块：管理主机名 yum模块：使用yum命令完成程序包管理 service模块：服务管理 group模块：增加或删除组 user模块：用户管理 setup模块：收集主机里面的各种信息 YAML 数据结构 playbook 核心元素 playbook的基础组件 playbook格式 ansible-playbook命令 Handlers tags Ansible官方资源 Ansible Documentation Ansible Github Ansible中文权威指南 Ansible特性 模块化：调用特定的模块，完成特定的任务； 基于Python语言研发，由Paramikko，PyYAML和Jinja2三个核心库实现； 部署简单：agentless； 支持自定义模块，使用任意编程语言； 强大的playbook机制； 幂等性； 安装及程序环境 程序 ansible ansible-playbook ansible-doc 配置文件 /etc/ansible/ansible.cfg 主机清单 /etc/ansible/hosts 插件目录 /usr/share/ansible_plugins/ 安装ansible yum install ansible -y ansible命令的使用 Usage: ansible host-pattern [options] 常用选项： -m MOD_NAME 默认的MOD_NAME 是command； -a MOD_ARGS 配置Host Inventory /etc/ansible/hosts HOST_PATTERN1 HOST_PATTERN2 添加两台主机做测试用 [root@falcon ansible]# cat hosts [falcon] 172.27.2.79 172.27.2.88 SSH免密码登录设置 生成私钥和公钥 [root@falcon ~]# ssh-keygen -b 4096 -t rsa -P '' Generating public/private rsa key pair. Enter file in which to save the key (/root/.ssh/id_rsa): Your identification has been saved in /root/.ssh/id_rsa. Your public key has been saved in /root/.ssh/id_rsa.pub. The key fingerprint is: d0:1e:00:12:68:7d:d1:2d:2d:a1:e2:91:c2:79:ef:00 root@falcon.symbio.com The key s randomart image is: +--[ RSA 4096]----+ | .+..o+.+ | |o..o...* o | |.E =... = | | = + o . | | o . S | | o | | . | | | | | +-----------------+ [root@falcon ~]# ls ~/.ssh/ authorized_keys id_rsa id_rsa.pub known_hosts 复制公钥文件为authorized_keys [root@falcon ~]# cd ~/.ssh/ [root@falcon .ssh]# ls authorized_keys id_rsa id_rsa.pub known_hosts [root@falcon .ssh]# cat id_rsa.pub ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQCsB35DoT7JF2ARqsyGib0oYSDR3EGbW0PleHPDQEnhlxpth35Pmg8dbpyGpoQwO8EqdGVy0N+O/rGhJ1QYO+kG9oNuDfzec8E0ANqNznNZpGgX8me3JQ2GRgMBOUVFg1wiVuhxE3Ww2pIZC2NhSz8LNtpSHlTEWwJ6uHhP9MUiAdxrk3uHGPj+KgnkaSiYOH7pD3HBVEKC8ywJsAEwBJCYz/1P86HMBRC8bcrL8x9FasCx+WObJYWVQs1urhw4XNHtbVZqFgeVtmgnpZuQr4SuARJQEPQ/NAaAdIPdYGph6jJop0wKHP2WhwIBbf9FX34FAWJZnD49FCtn5RAflukXlY7gJBxoStAApzjkxy48r8mU4kxufXXMcgf68r/W+YSMdD4BGpdgJBQiPssBvF3/H+6RD6EE51CrOH2slUitMLi2F7iCWZetteqfBYXR5YIA8H4V4dG3GPNzVTW0U0vhFagpA9T0vGhciWr9P0CgvSzRTQO4YlkKLXJfoiQWZBTsEHmttgxDfCQ1w6hoNTz8sMXGtsQvrkC35nR+mNFISKmrAH3jaJ2bgDT6PqgG/OGdI8u1GDjnKSNA96SnWjwEjTfDnGwN2LAp2GNRA8A+ACJBCN3vZRg0inmWQdeahIDJ/tUklVoLRdOHUd4iowWIUwHGvIwvLfh8AWIkT9fWxw== root@falcon.symbio.com [root@falcon .ssh]# cat id_rsa.pub >> authorized_keys [root@falcon .ssh]# chmod 600 authorized_keys [root@falcon .ssh]# ll authorized_keys -rw-------. 1 root root 1156 6月 21 16:12 authorized_keys [root@falcon .ssh]# cat authorized_keys ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCqjaWO8MLMPSGfiVWS8z7z7Jb00E8A+BLiIA8mzEN0n4pcw6coUWEcSHEEM27kC920NiQMvO6uTFtTUP4a1mJxP6P+AmV/989H92naJXnjb6X8IPh3KOhSX0a619lg4hDPr0qiGz2Tx9go7hoAp5ZMOoa6jYVzjJrKRQdNcN8xD7jFJ7SdxXbOWwECJse1InJ4j+gQzs635dgS129X6x6lirxt3t9wuuo9VkgL52nPd1rsXjQCxmuGUw7chZhS0n6Wj1p1Tu5SdF0z9Tk83NIuVRsBgI7ctfy6FUQTjHgg87tdE7dL9ovFTk49cF8qNHKUnhsguOIL3rVXMwr/XptH root@localhost.localdomain ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQCsB35DoT7JF2ARqsyGib0oYSDR3EGbW0PleHPDQEnhlxpth35Pmg8dbpyGpoQwO8EqdGVy0N+O/rGhJ1QYO+kG9oNuDfzec8E0ANqNznNZpGgX8me3JQ2GRgMBOUVFg1wiVuhxE3Ww2pIZC2NhSz8LNtpSHlTEWwJ6uHhP9MUiAdxrk3uHGPj+KgnkaSiYOH7pD3HBVEKC8ywJsAEwBJCYz/1P86HMBRC8bcrL8x9FasCx+WObJYWVQs1urhw4XNHtbVZqFgeVtmgnpZuQr4SuARJQEPQ/NAaAdIPdYGph6jJop0wKHP2WhwIBbf9FX34FAWJZnD49FCtn5RAflukXlY7gJBxoStAApzjkxy48r8mU4kxufXXMcgf68r/W+YSMdD4BGpdgJBQiPssBvF3/H+6RD6EE51CrOH2slUitMLi2F7iCWZetteqfBYXR5YIA8H4V4dG3GPNzVTW0U0vhFagpA9T0vGhciWr9P0CgvSzRTQO4YlkKLXJfoiQWZBTsEHmttgxDfCQ1w6hoNTz8sMXGtsQvrkC35nR+mNFISKmrAH3jaJ2bgDT6PqgG/OGdI8u1GDjnKSNA96SnWjwEjTfDnGwN2LAp2GNRA8A+ACJBCN3vZRg0inmWQdeahIDJ/tUklVoLRdOHUd4iowWIUwHGvIwvLfh8AWIkT9fWxw== root@falcon.symbio.com 把公钥传送到其他主机 [root@falcon .ssh]# scp authorized_keys 172.27.2.88:/root/.ssh/ root@172.27.2.88's password: authorized_keys 100% 1156 1.1KB/s 00:00 在被控制端主机查看密钥并确认其权限 [root@falcon .ssh]# ssh root@172.27.2.88 Last login: Wed Jun 21 14:40:32 2017 from 172.27.8.23 [root@pythonenv ~]# ls -l ~/.ssh/authorized_keys -rw-------. 1 root root 1156 6月 21 16:15 /root/.ssh/authorized_keys 使用ansible的ping模块测试两台主机的连通性 [root@falcon ansible]# ansible falcon -m ping 172.27.2.79 | SUCCESS => { \"changed\": false, \"ping\": \"pong\" } 172.27.2.88 | SUCCESS => { \"changed\": false, \"ping\": \"pong\" } 同步主机之间的时间以免造成日志混乱 [root@falcon ansible]# ansible falcon -a \"ntpdate 10.60.4.180\" 172.27.2.79 | SUCCESS | rc=0 >> 21 Jun 16:34:34 ntpdate[17103]: step time server 10.60.4.180 offset 18.504664 sec 172.27.2.88 | SUCCESS | rc=0 >> 21 Jun 16:34:34 ntpdate[13776]: step time server 10.60.4.180 offset -10.289925 sec ansible模块 获取模块列表 [root@falcon ansible]# ansible-doc -l 获取指定模块的使用帮助 ansible-doc -s MOD_NAME [root@falcon ansible]# ansible-doc -s user 常用模块 ping模块：探测目标主机是否存活； command模块：在远程主机执行命令，是Ansible的默认模块； shell模块：在远程主机上调用shell解释器运行命令，支持shell的各种特性，例如管道、重定向等； 注意：command和shell模块的核心参数直接为命令本身；而其他模块的参数通常为\"key=value\"格式； copy模块：复制文件到远程主机 1.复制文件： -a \"src='#' '' \" [root@falcon ~]# cat anaconda-ks.cfg >> ./copy_module_test.txt [root@falcon ~]# ansible falcon -m copy -a \"src='copy_module_test.txt' dest='/root/'\" [root@falcon ~]# ansible falcon -m command -a \"ls -lh /root/copy_module_test.txt\" 172.27.2.79 | SUCCESS | rc=0 >> -rw-r--r--. 1 root root 1.3K 6月 21 16:53 /root/copy_module_test.txt 172.27.2.88 | SUCCESS | rc=0 >> -rw-r--r--. 1 root root 1.3K 6月 21 16:54 /root/copy_module_test.txt 2.给定内容生成文件： -a \"content= dest= \" [root@falcon ~]# ansible falcon -m copy -a \"content='This is a test conten for copy module' dest='/root/content.txt'\" [root@falcon ~]# ansible falcon -m command -a \"cat /root/content.txt\" 172.27.2.79 | SUCCESS | rc=0 >> This is a test conten for copy module 172.27.2.88 | SUCCESS | rc=0 >> This is a test conten for copy module 如果要传送文件，该主机的指定目录需要存在,否则会报错； file模块：设置文件的属性 1.创建目录： -a \"path= state=directory\" 2.创建链接文件： -a \"path= src='#' \" /p> 3.删除文件： -a \"path= state=absent\" fetch模块：从远程主机拿文件 [root@falcon ~]# ansible 172.27.2.88 -m fetch -a \"src=/root/anaconda-ks.cfg dest=/root/anaconda_from_88.cfg\" 172.27.2.88 | SUCCESS => { \"changed\": true, \"checksum\": \"1f02d8a0524f7e32cd612c2a54c576bb93bddb4e\", \"dest\": \"/root/anaconda_from_88.cfg/172.27.2.88/root/anaconda-ks.cfg\", \"md5sum\": \"9692f1d9a8808495a1d8514e3ec36c21\", \"remote_checksum\": \"1f02d8a0524f7e32cd612c2a54c576bb93bddb4e\", \"remote_md5sum\": null } [root@falcon ~]# ls -lh anaconda_from_88.cfg/172.27.2.88/root/anaconda-ks.cfg -rw-------. 1 root root 1.7K 6月 21 17:49 anaconda_from_88.cfg/172.27.2.88/root/anaconda-ks.cfg 给定的dest应该是一个目录，fetch模块会在该目录下根据主机进行区分； cron模块：管理计划任务条目； 确定时间： minute= hour= day= month= weekday= job='要执行的命令' name='给这个任务取个名字，后期删除的时候可以用' user='USERNAME' 指定为某个用户的计划任务； state={present|absent},present为添加，absent为删除； hostname模块：管理主机名 yum模块：使用yum命令完成程序包管理 state: install (present' orinstalled', `latest')； state: remove (absent' orremoved'); name: Package Name； service模块：服务管理 name=\"Service Name\" state=\"{started | stopped | restarted}\" enabled=\"{yes | no}\" runlevel= 仅对于init script而言； group模块：增加或删除组 user模块：用户管理 setup模块：收集主机里面的各种信息 YAML YAML是一种数据序列化工具的语言格式； [root@falcon ~]# yum info PyYAML Loaded plugins: fastestmirror Loading mirror speeds from cached hostfile * base: centos.uhost.hk * extras: centos.uhost.hk * updates: mirror.vpshosting.com.hk Installed Packages Name : PyYAML Arch : x86_64 Version : 3.10 Release : 11.el7 Size : 630 k Repo : installed From repo : base Summary : YAML parser and emitter for Python URL : http://pyyaml.org/ License : MIT Description : YAML is a data serialization format designed for human readability and : interaction with scripting languages. PyYAML is a YAML parser and : emitter for Python. : : PyYAML features a complete YAML 1.1 parser, Unicode support, pickle : support, capable extension API, and sensible error messages. PyYAML : supports standard YAML tags and provides Python-specific tags that : allow to represent an arbitrary Python object. : : PyYAML is applicable for a broad range of tasks from complex : configuration files to object serialization and persistance. 数据结构 key:value -item1 -item2 -item3 例如： {name:jason,age:21} playbook 核心元素 Tasks:任务，由模块定义的操作的列表； Variables:变量； Templates:模板，即使用了模板语法的文本文件； Handlers: 有特定条件触发的Tasks； Roles:角色； playbook的基础组件 Hosts:运行指定任务的目标主机； remote_user: 在远程主机上以那个身份执行； sudo_user: 非管理员需要拥有sudo权限； tasks: 任务列表； playbook格式 (1) action: module arguments (2) module: arguments ansible-playbook命令 (1) 检测语法 ansible-playbook --syntax-check /path/to/playbook.yaml (2) 测试运行 ansible-playbook -C /path/to/playbook.yaml --list-hosts --list-tasks --list-tags (3) 运行 ansible-playbook /path/to/playbook.yaml -t TAGS, --tags=TAGS --skip-tags=SKIP_TAGS --start-at-task=START_AT Example 1: 定义一个playbook任务来新增用户和组，定义一个yaml的模板； [root@falcon ansible]# vim group.yaml [root@falcon ansible]# cat group.yaml - hosts: falcon remote_user: root tasks: - name: add a group group: name=pbgroup system=true - name: add a user user: name=pbuser group=pbgroup system=true 查查语法有没有错误，没有提示即表示语法应该没有问题。 [root@falcon ansible]# ansible-playbook --syntax-check group.yaml playbook: group.yaml 测试运行看看，-C表示仅测试跑一边，但是不会实际操作: [root@falcon ansible]# ansible-playbook -C group.yaml PLAY [falcon] ***************************************************************************************************************************************************************************************************** TASK [Gathering Facts] ******************************************************************************************************************************************************************************************** ok: [172.27.2.79] ok: [172.27.2.88] TASK [add a group] ************************************************************************************************************************************************************************************************ changed: [172.27.2.79] changed: [172.27.2.88] TASK [add a user] ************************************************************************************************************************************************************************************************* changed: [172.27.2.79] changed: [172.27.2.88] PLAY RECAP ******************************************************************************************************************************************************************************************************** 172.27.2.79 : ok=3 changed=2 unreachable=0 failed=0 172.27.2.88 : ok=3 changed=2 unreachable=0 failed=0 也可以单独测试某些特定的选项： 仅查看影响的主机： [root@falcon ansible]# ansible-playbook -C group.yaml --list-hosts playbook: group.yaml play #1 (falcon): falcon TAGS: [] pattern: [u'falcon'] hosts (2): 172.27.2.79 172.27.2.88 查看运行哪些任务： [root@falcon ansible]# ansible-playbook -C group.yaml --list-tasks playbook: group.yaml play #1 (falcon): falcon TAGS: [] tasks: add a group TAGS: [] add a user TAGS: [] 查看哪个任务打标了，这里并没有任何任务打标记： [root@falcon ansible]# ansible-playbook -C group.yaml --list-tags playbook: group.yaml play #1 (falcon): falcon TAGS: [] TASK TAGS: [] 正式运行该任务： [root@falcon ansible]# ansible-playbook group.yaml PLAY [falcon] ***************************************************************************************************************************************************************************************************** TASK [Gathering Facts] ******************************************************************************************************************************************************************************************** ok: [172.27.2.79] ok: [172.27.2.88] TASK [add a group] ************************************************************************************************************************************************************************************************ changed: [172.27.2.79] changed: [172.27.2.88] TASK [add a user] ************************************************************************************************************************************************************************************************* changed: [172.27.2.88] changed: [172.27.2.79] PLAY RECAP ******************************************************************************************************************************************************************************************************** 172.27.2.79 : ok=3 changed=2 unreachable=0 failed=0 172.27.2.88 : ok=3 changed=2 unreachable=0 failed=0 验证执行效果： [root@falcon ansible]# ansible falcon -a \"tail -1 /etc/passwd\" 172.27.2.79 | SUCCESS | rc=0 >> pbuser:x:995:993::/home/pbuser:/bin/bash 172.27.2.88 | SUCCESS | rc=0 >> pbuser:x:987:984::/home/pbuser:/bin/bash [root@falcon ansible]# ansible falcon -a \"getent group pbgroup\" 172.27.2.88 | SUCCESS | rc=0 >> pbgroup:x:984: 172.27.2.79 | SUCCESS | rc=0 >> pbgroup:x:993: Example 2: 定义一个playbook任务来修改配置文件中的监听端口； [root@falcon ansible]# cat httpd.yaml - hosts: falcon remote_user: root tasks: - name: install httpd package yum: name=httpd state=latest - name: backup apache conf file shell: cp /etc/httpd/conf/httpd.conf{,.bak} - name: install conf file copy: src=/root/ansible/httpd.conf dest=/etc/httpd/conf/httpd.conf - name: start httpd service service: name=httpd state=started enabled=yes [root@falcon ansible]# ansible-playbook --syntax-check httpd.yaml playbook: httpd.yaml 执行playbook [root@falcon ansible]# ansible-playbook httpd.yaml PLAY [falcon] ***************************************************************************************************************************************************************************************************** TASK [Gathering Facts] ******************************************************************************************************************************************************************************************** ok: [172.27.2.79] ok: [172.27.2.88] TASK [install httpd package] ************************************************************************************************************************************************************************************** ok: [172.27.2.79] ok: [172.27.2.88] TASK [backup apache conf file] ************************************************************************************************************************************************************************************ changed: [172.27.2.79] changed: [172.27.2.88] TASK [install conf file] ****************************************************************************************************************************************************************************************** changed: [172.27.2.88] changed: [172.27.2.79] TASK [start httpd service] **************************************************************************************************************************************************************************************** changed: [172.27.2.88] changed: [172.27.2.79] PLAY RECAP ******************************************************************************************************************************************************************************************************** 172.27.2.79 : ok=5 changed=3 unreachable=0 failed=0 172.27.2.88 : ok=5 changed=3 unreachable=0 failed=0 验证： 配置文件是否备份成功： [root@falcon ansible]# ansible falcon -m shell -a \"ls -lh /etc/httpd/conf/\" 172.27.2.79 | SUCCESS | rc=0 >> total 40K -rw-r--r--. 1 root root 12K 6月 22 11:28 httpd.conf -rw-r--r--. 1 root root 12K 6月 22 11:28 httpd.conf.bak -rw-r--r--. 1 root root 13K 4月 13 05:04 magic 172.27.2.88 | SUCCESS | rc=0 >> total 40K -rw-r--r--. 1 root root 12K 6月 22 11:28 httpd.conf -rw-r--r--. 1 root root 12K 6月 22 11:28 httpd.conf.bak -rw-r--r--. 1 root root 13K 4月 13 05:04 magic 修改后的监听端口： [root@falcon ansible]# ansible falcon -m shell -a \"ss -tnl | grep 8008\" 172.27.2.79 | SUCCESS | rc=0 >> LISTEN 0 128 :::8008 :::* 172.27.2.88 | SUCCESS | rc=0 >> LISTEN 0 128 :::8008 :::* Handlers 由特定条件触发的Tasks； handlers用于当关注的资源发生变化时采取一定的操作。 “notify”这个action可用于在每个play的最后被触发，这样可以避免多次有改变发生时都执行指定的操作，取而代之在所有的变化发生完成后一次性地执行指定操作。 在notify中列出的操作称为handler也即notify中调用handler中定义的操作。 注意： 在notify中定义内容一定要和tasks中定义的 - name内容一样，这样才能达到触发的效果，否则不会生效。 - name: template configuration file template: src=template.j2 dest=/etc/foo.conf notify: - restart memcached - restart apache #handler是task列表这些task与前述的task并没有本质上的不同。 handlers: - name: restart memcached service: name=memcached state=restarted - name: restart apache service: name=apache state=restarted 格式： tasks: - name: TASK_NAME module: arguments notify: - HANDLER_NAME1 - HANDLER_NAME2 handlers: - name: HANDLER_NAME1 module: arguments - name: HANDLER_NAME2 module: arguments Example: 在上面httpd.yaml的基础上修改； 在Ansible端修改配置文件中的监听端口为8009。 修改httpd.yaml如下： [root@falcon ansible]# cat httpd.yaml - hosts: falcon remote_user: root tasks: - name: install httpd package yum: name=httpd state=latest - name: backup apache conf file shell: cp /etc/httpd/conf/httpd.conf{,.bak} - name: install conf file copy: src=/root/ansible/httpd.conf dest=/etc/httpd/conf/httpd.conf notify: restart httpd service - name: start httpd service service: name=httpd state=started enabled=yes handlers: - name: restart httpd service service: name=httpd state=restarted [root@falcon ansible]# ansible-playbook --syntax-check httpd.yaml playbook: httpd.yaml [root@falcon ansible]# ansible-playbook httpd.yaml PLAY [falcon] ***************************************************************************************************************************************************************************************************** TASK [Gathering Facts] ******************************************************************************************************************************************************************************************** ok: [172.27.2.79] ok: [172.27.2.88] TASK [install httpd package] ************************************************************************************************************************************************************************************** ok: [172.27.2.79] ok: [172.27.2.88] TASK [backup apache conf file] ************************************************************************************************************************************************************************************ changed: [172.27.2.88] changed: [172.27.2.79] TASK [install conf file] ****************************************************************************************************************************************************************************************** changed: [172.27.2.88] changed: [172.27.2.79] TASK [start httpd service] **************************************************************************************************************************************************************************************** ok: [172.27.2.79] ok: [172.27.2.88] RUNNING HANDLER [restart httpd service] *************************************************************************************************************************************************************************** changed: [172.27.2.79] changed: [172.27.2.88] PLAY RECAP ******************************************************************************************************************************************************************************************************** 172.27.2.79 : ok=6 changed=3 unreachable=0 failed=0 172.27.2.88 : ok=6 changed=3 unreachable=0 failed=0 验证结果： ```bash [root@falcon ansible]# ansible falcon -m shell -a \"ss -tnlp | grep 8009\" 172.27.2.79 | SUCCESS | rc=0 >> LISTEN 0 128 :::8009 :::* users:((\"httpd\",pid=23844,fd=4),(\"httpd\",pid=23843,fd=4),(\"httpd\",pid=23842,fd=4),(\"httpd\",pid=23841,fd=4),(\"httpd\",pid=23840,fd=4),(\"httpd\",pid=23838,fd=4)) 172.27.2.88 | SUCCESS | rc=0 >> LISTEN 0 128 :::8009 :::* users:((\"httpd\",17037,4),(\"httpd\",17036,4),(\"httpd\",17035,4),(\"httpd\",17034,4),(\"httpd\",17033,4),(\"httpd\",17032,4),(\"httpd\",17031,4)) --- 在众多模块中只有command和shell模块仅需要给定一个列表而无需使用“key=value”格式； 例如： ```yaml tasks: - name: disable selinux command: /sbin/setenforce 0 如果命令或脚本的退出码不为0可以使用如下方式替代： tasks: - name: run this command and ignore the result. shell: /usr/bin/somecommand || /bin/true 也可以使用ignore_errors来忽略错误信息； - name: run this command and ignore the result shell: /usr/bin/somecommand ignore_errors: True tags 给指定的任务定义一个调用标识； tags用于让用户选择运行或略过playbook中的部分代码。Ansible具有幂等性，因此会自动跳过没有变化的部分。 即便如此，有些代码为测试其确实没有发生变化的时间会非常的长； 此时如果确信其没有变化就可以通过tags跳过这些代码片段； 定义tags的格式： - name: NAME module: arguments tags: TAG_ID Example：修改ansible端配置文件中的监听端口后，使用ansible-playbook -t TAG_ID[,...] 执行指定的tasks； [root@falcon ansible]# cat httpd.yaml - hosts: falcon remote_user: root tasks: - name: install httpd package yum: name=httpd state=latest - name: backup apache conf file shell: cp /etc/httpd/conf/httpd.conf{,.bak} - name: install conf file copy: src=/root/ansible/httpd.conf dest=/etc/httpd/conf/httpd.conf tags: instconf notify: restart httpd service - name: start httpd service service: name=httpd state=started enabled=yes handlers: - name: restart httpd service service: name=httpd state=restarted [root@falcon ansible]# ansible-playbook --syntax-check httpd.yaml playbook: httpd.yaml 此处可以查看到该yaml脚本有一个标签，影响着falcon组： [root@falcon ansible]# ansible-playbook --list-tags httpd.yaml playbook: httpd.yaml play #1 (falcon): falcon TAGS: [] TASK TAGS: [instconf] 测试运行 ```bash [root@falcon ansible]# ansible-playbook -C -t instconf httpd.yaml PLAY [falcon] * TASK [Gathering Facts] ** ok: [172.27.2.79] ok: [172.27.2.88] TASK [install conf file] ** changed: [172.27.2.88] changed: [172.27.2.79] RUNNING HANDLER [restart httpd service] * changed: [172.27.2.88] changed: [172.27.2.79] PLAY RECAP ** 172.27.2.79 : ok=3 changed=2 unreachable=0 failed=0172.27.2.88 : ok=3 changed=2 unreachable=0 failed=0 正式运行一下，指定以instconf的标签运行，所以此处不会显示其他多余的信息，包括安装httpd包和启动httpd服务; ```bash [root@falcon ansible]# ansible-playbook -t instconf httpd.yaml PLAY [falcon] ***************************************************************************************************************************************************************************************************** TASK [Gathering Facts] ******************************************************************************************************************************************************************************************** ok: [172.27.2.79] ok: [172.27.2.88] TASK [install conf file] ****************************************************************************************************************************************************************************************** changed: [172.27.2.88] changed: [172.27.2.79] RUNNING HANDLER [restart httpd service] *************************************************************************************************************************************************************************** changed: [172.27.2.88] changed: [172.27.2.79] PLAY RECAP ******************************************************************************************************************************************************************************************************** 172.27.2.79 : ok=3 changed=2 unreachable=0 failed=0 172.27.2.88 : ok=3 changed=2 unreachable=0 failed=0 验证该结果： [root@falcon ansible]# cat httpd.conf | grep ^Listen Listen 8099 [root@falcon ansible]# ansible falcon -m shell -a \"ss -tnl | grep 8099\" 172.27.2.79 | SUCCESS | rc=0 >> LISTEN 0 128 :::8099 :::* 172.27.2.88 | SUCCESS | rc=0 >> LISTEN 0 128 :::8099 :::* 也可以对同一个文件标记多个标签同时执行,只需要执行ansible-playbook -t TAG_ID1,TAG_ID2[,....] *.yaml Copyright && Guiyin.Xiong From ==>> notebook.sslinux.com all right reserved，powered by Gitbook2017年6月12日 2017-09-20 16:37:48 "}}